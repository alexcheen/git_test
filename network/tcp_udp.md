#为什么会发生 TCP 粘包、拆包？
 * 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
 * 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
 * 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
 * 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
# 粘包、拆包解决办法
由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：
 * 消息定长：发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
 * 设置消息边界：服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
 * 将消息分为消息头和消息体：消息头中包含表示消息总长度（或者消息体长度）的字段。
 * 更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。
